声明该类型的实例调用构造函数和析构函数只需要知道函数的地址即可虚函数生成虚函数表，每一个实例中添加一个指向虚函数表的指针。（虚函数的调用机制）class CMyString{public:	CMyString(char* pData = NULL);	CMyString(const CMyString& str);	~CMyString(void);private:	char* m_pData;};operater c++中的关键字_重载操作符CMyString& CMyString::operater =(const CMyString& str){	if(this == &str)		return *this;	delete []m_pData;	m_pDatam = NULL;	m_pDatam = new char[strlen(str.m_pDatam) + 1];	strcpy(m_pDatam, str.m_pDatam}#面试题4，替换空格void ReplaceBlank(char string[], int length){	if (string == NULL && length <= 0)		return;	/*originalLength为字符串string的实际长度*/	int originalLength = 0;	int numberOfBlank = 0;	int i = 0;	while (string[i] != '\0'	{		++ originalLength;				if (string[i] == ' ')			++ numberOfBlank;					++ i;	}		/*newLength 为把空格替换成'%20'之后的长度*/	int newLength = originalLength + numberOfBlank * 2;	if(newLength > length)		return;		int indexOfOriginal = originalLength;	int indexOfNew = newLength;	while (indexOfOriginal >= 0 && indexOfNew > indexOfOriginal)	{		if(string[indexOfOriginal == ' ') {			string[indexOfNew --] = '0';			string[indexOfNew --] = '2';			string[indexOfNew --] = '%';		}		else		{			string[indexOfNew --] = string[indexOfOriginal];		}				-- indexOfOriginal;			}		}#练习题：有两个排序的数组A1和A2,内存在A1的末尾有足够多的空间容纳A2。请实现一个函数，把A2中的所有数字插入到A1中并且所有的数字是排序。struct ListNode{	int m_nValue;	ListNode *m_pNext;};void AddToTail (ListNode** pHead, int value){	ListNode *pNew = new ListNode();	pNew->m_nValue = value;	pNew->m_pNext = NULL;		if(*pHead == NULL)	{		*pHead = pNew;	}	else	{		ListNode *pNode = *pHead;				while(pNode->m_pNext != NULL)			pNode = pNode->m_pNext;				pNode->m_pNext = pNew;	}}void RemoveNode(ListNode** pHead, int value){	if (pHead == NULL || *pHead == NULL)		retuen;			ListNode *pToBeDeleted = NULL;	if ((*pHead)->m_nValue == value)	{		pToBeDeleted = *pHead;		*pHead = (*pHead)->m_pNext;	}	else	{		#面试题5：从尾到头打印链表――通过栈实现struct ListNode{	int m_nValue;	ListNode *m_pNext;};void PrintListReversingly_Iteratively(ListNode *pHead){	std::stack<ListNode *> nodes;		ListNode *pNode = pHead;	while(pNode != NULL)	{		nodes.push(pNode);		pNode = pNode->m_pNext;	}		while (!nodes.empty())	{		pNode = nodes.top();		printf("%d\t", pNode->m_nValue);		nodes.pop();	}}递归的本质是一个栈结构#用递归实现――容易栈溢出void PrintListReversingly_Iteratively(ListNode *pHead){	if (pHead != NULL)	{		if (pHead->m_pNext != NULL)		{			PrintListReversingly_Iteratively(pHead->m_pNext);		}				printf("%\t", pHead->m_nValue);	}}前中后序遍历，前，先根后左右；中，左，跟，右；后，先左，右，最后根。根据根节点的先后来判断。都有递归和循环两种不同的实现方法。递归简洁一些。6种实现方法都了如指掌：1）宽度优先遍历：#重建二叉树